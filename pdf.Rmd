---
title: "ss"
output:
  pdf_document: default
  html_document: default
date: '2022-05-03'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

------------------------------------------------------------------------

## Probability Density Estimation

### Packages

```{r}
require(copula)
require(kdensity)
require(VC2copula)
require(VineCopula)
require("spcopula")
```

### Data Preparation

```{r}
t_merged_20220222_20 <- read.csv("C:/Users/d50021948/Desktop/datas/t_merged_20220222_20.csv")
t_merged_20220222_21 <- read.csv("C:/Users/d50021948/Desktop/datas/t_merged_20220222_21.csv")
t_merged_20220223_20 <- read.csv("C:/Users/d50021948/Desktop/datas/t_merged_20220223_20.csv")
data <- rbind(t_merged_20220222_20, t_merged_20220222_21, t_merged_20220223_20)
mydata <-  data[, c("first_frame_view",
                    "quic_server_0rtt",
                    "connection_cost_time",
                    "first_app_data_cost_time",
                    "stream_first_target_frame_sent_interval",
                    "first_app_data_effective_ack_cost_time",
                    "stream_first_target_frame_packets_lost",
                    "stream_first_target_frame_tlp_count",
                    "stream_first_target_frame_size",
                    "stream_first_target_frame_average_estimated_bandwidth",
                    "stream_first_target_frame_packets_spuriously_retransmitted",
                    "stream_first_target_frame_completion_time",
                    "first_frame_render_cost")]
mydata <- subset(mydata, mydata$first_frame_view > 0)
mydata <- subset(mydata, mydata$stream_first_target_frame_completion_time>0)
mydata$stream_first_target_frame_trans_time <- mydata$stream_first_target_frame_size/mydata$stream_first_target_frame_average_estimated_bandwidth 
mydata <- na.omit(mydata)
```

### Treatment and Outcome

Here we use variable first_frame_render_cost as the treatment, and first_frame_view as the outcome, and we are aiming to model the probability density function, and we need to use `pobs` functions to get the uniform distribution of the dataset

```{r}
tr <- mydata$first_frame_render_cost
tr2 <- mydata$connection_cost_time
tr3 <- mydata$stream_first_target_frame_completion_time
tr4 <- mydata$stream_first_target_frame_sent_interval
tr5 <- mydata$first_app_data_cost_time
ou <- mydata$first_frame_view
mdata <- cbind(tr, ou)
umdata <- pobs(mdata)
treat <- umdata[,1]
out <- umdata[,2]
```

### Kernel Probability Density Estimation

Here is the estimation of the first_frame_view, and comparison with the histogram

```{r}
f <- kdensity(mdata[,2], start = "gamma", kernel = "gamma", bw = "RHE")
hist(mdata[,2], main = "first_frame_View", xlab = "first_frame_view")
par(new=TRUE)
plot(f, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "")
```

Here is the estimation of the first_frame_render_cost

```{r}
g <- kdensity(mdata[,1], start = "gamma", kernel = "gamma", bw = "RHE")
hist(mdata[,1], main = "first_frame_render_cost", xlab = "first_frame_render_cost")
par(new=TRUE)
plot(g, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "")
```
Here is the estimitation of connection_cost_time
```{r}
mdata2 <- cbind(tr2, ou)
umdata2 <- pobs(mdata2)
mdata2 <- subset(mdata2, mdata2[,1] > 0)
treat2 <- umdata2[,1]
out2 <- umdata2[,2]
g2 <- kdensity(mdata2[,1], start = "gamma", kernel = "gamma", bw = "RHE")
hist(mdata2[,1], main = "connection_cost_time", xlab = "connection_cost_time")
par(new=TRUE)
plot(g2, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "")
```
Here is the estimation of stream_first_target_frame_completion_time
```{r}
mdata3 <- cbind(tr3, ou)
umdata3 <- pobs(mdata3)
mdata3 <- subset(mdata3, mdata3[,1] > 0)
treat3 <- umdata3[,1]
out3 <- umdata3[,2]
# g3 <- kdensity(mdata3[,1], start = "gamma", kernel = "gamma", bw = "RHE")
hist(mdata2[,1], main = "stream_first_target_frame_completion_time", xlab = "stream_first_target_frame_completion_time")
par(new=TRUE)
plot(g2, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "")
```

Since the distribution of stream_first_target_frame_completion_time is very biased, we do log transformation first
and do gaussian kernel estimation
```{r}
lmdata3 <- log(mdata3)
g3 <- kdensity(lmdata3[,1], start = "gaussian", kernel = "gaussian", bw = "RHE")
hist(lmdata3[,1], main = "log of stream_first_target_frame_completion_time", xlab = "log stream_first_target_frame_completion_time")
par(new=TRUE)
plot(g3, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "")
```

The estimation of stream_first_target_frame_sent_interval
```{r}
mdata4 <- cbind(tr4, ou)
umdata4 <- pobs(mdata4)
lmdata4 <- log(mdata4)
g4 <- kdensity(lmdata4[,1], start = "gaussian", kernel = "gaussian", bw = "RHE")
hist(lmdata4[,1], main = "log of stream first target frame sent interval", xlab = "log stream first target frame sent interval")
par(new=TRUE)
plot(g4, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "")
```
### Copula function estimation

we define marginal functions, just return the function

```{r}
margin_treatment <- function(x){
  return(g(x))
}
margin_out <- function(x){
  return(f(x))
}
margin_log_treatment3 <- function(x){
  return(exp(g3(x)))
}
margin_log_treatment4 <- function(x){
  return(exp(g4(x)))
}
```

we define culmulative function, integrate the marginal function

```{r}
cdt <- function(x){
  res <- integrate(margin_treatment, -Inf, x)$value
  if (res > 1){return(1)}
  else{return(res)}
}
cdt3 <- function(x){
  res <- integrate(margin_log_treatment3, -Inf, x)$value
  if (res > 1){return(1)}
  else{return(res)}
}
cdo <- function(x){
  res <- integrate(margin_out, -Inf, x)$value
  if (res > 1){return(1)}
  else{return(res)}
}
cdt3vec <- function(t){return(sapply(t, cdt3))}
cdt2vec <- function(t){return(sapply(t, cdt))}
cdo2vec <- function(t){sapply(t, cdo)}
```

We define the conditional probability function, it is a joint distribution

```{r}
mycop <- BiCopEst(out, treat, family = 2)
mycop3 <- BiCopEst(out3, treat3, family = 2)
FOT <- function(o, t){
  a <- cdo2vec(o)
  b <- cdt2vec(t)
  BiCopPDF(a, b, mycop)*margin_out(o)
}
FOT3 <- function(o, t){
  a <- cdo2vec(o)
  b <- cdt3vec(t)
  BiCopPDF(a, b, mycop3)*margin_out(o)
}
```

when first_frame_render_cost is 54 and 100 respectively

```{r}
FOTm <- function(x){
  FOT(x,54)
}
FOTmm <- function(x){
  FOT(x, 100)
}
FOT1vec <- function(t){sapply(t, FOTm)}
FOT2vec <- function(t){sapply(t, FOTmm)}

FOTm3 <- function(x){
  FOT3(x,54)
}
FOTmm3 <- function(x){
  FOT3(x, 100)
}
FOT1vec3 <- function(t){sapply(t, FOTm3)}
FOT2vec3 <- function(t){sapply(t, FOTmm3)}
```

definition of expectaion function

```{r}
X <- seq(200, 300, by = 2)
E1 <- function(x){
  return(x*FOTm(x))
}
E2 <- function(x){
  return(x*FOTmm(x)) 
}
E1vec <- function(t){return(sapply(t,E1))}
E2vec <- function(t){return(sapply(t,E2))}

E13 <- function(x){
  return(x*FOTm3(x))
}
E23 <- function(x){
  return(x*FOTmm3(x)) 
}
E1vec3 <- function(t){return(sapply(t,E13))}
E2vec3 <- function(t){return(sapply(t,E23))}
```

For Copula function estimation, we use gamma kernel function, since the data is very biased

we plot the pdf of first_frame_view given that first_frame_render_cost is 54

```{r}
plot(X, FOT1vec(X), ylab = "PDF", xlab = "first_frame_view")
```

we plot the pdf of first_frame_view given that first_frame_completion_time is 54
```{r}
plot(X, FOT1vec3(X), ylab = "PDF", xlab = "ffct")
```
we plot the PDF of first_frame_view given first_render_cost is 100

```{r}
plot(X, FOT2vec(X), ylab = "PDF", xlab = "first_frame_view")
```

we plot the pdf of first_frame_view given that first_frame_completion_time is 54
```{r}
plot(X, FOT1vec3(X), ylab = "PDF", xlab = "ffct")
```
Then, we can integrate the PDF to get the expectation value under each value of treatmetn

```{r}
Ex1 <- integrate(E1vec, -Inf, Inf)
Ex2 <- integrate(E2vec, -Inf, Inf)
Ex2$value - Ex1$value
```

Then, we can integrate the PDF to get the expectation value under each value of treatmetn

```{r}
Ex1 <- integrate(E1vec3, -Inf, Inf)
Ex2 <- integrate(E2vec3, -Inf, Inf)
Ex2$value - Ex1$value
```